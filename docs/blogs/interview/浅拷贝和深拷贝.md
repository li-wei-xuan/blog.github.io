---
title: 浅拷贝和深拷贝
date: 2022-12-26
tags:
 - interview
 - JavaScript
categories:
 - interview
---
## 赋值、浅拷贝、深拷贝
| 操作   | 是否指向同一个堆内存地址 | 基本数据类型         | 引用数据类型         |
| ------ | ------------------------ | -------------------- | -------------------- |
| 赋值   | 是                       | 改变会使原数据改变   | 改变会使原数据改变   |
| 浅拷贝 | 否                       | 改变不会使原数据改变 | 改变会使原数据改变   |
| 深拷贝 | 否                       | 改变不会使原数据改变 | 改变不会使原数据改变 |

### 赋值
```
赋值：就是对原对象的栈内存地址进行复制
```

#### 代码
```js
  let obj = {
    name:'zhangsan',
    age:8,
    friends:['lisi','wangwu']
  }
  let obj1 = obj

  obj1.name = '张三'
  obj1.friends[0] = '里斯'
  console.log('obj.name', obj.name) // obj.name 张三
  console.log('obj1.name', obj1.name) // obj1.name 张三
  console.log('obj.friends', obj1.friends) // obj.friends ['里斯', 'wangwu']
  console.log('obj1.friends', obj1.friends) // obj1.friends ['里斯', 'wangwu']
```

### 浅拷贝
```
浅拷贝 ：只复制指向某个对象的指针，而不复制对象本身，相当于是新建了一个对象，
        该对象复制了原对象的指针，新旧对象还是共用一个内存块
```

#### 浅拷贝实现方法
```js
  // 手写浅拷贝
  let obj = {
    name:'zhangsan',
    age:8,
    friends:['lisi','wangwu']
  }
  var obj1 = shallowCopy(obj)
  function shallowCopy (src){
   var newObj = {};
   for(var prop in src ){
       console.log(prop)
       if(src.hasOwnProperty(prop)){
           newObj[prop] = src[prop]
       }
   }
   return newObj
  } // let obj1 = obj
  obj1.name = '张三'
  obj1.friends[0] = '里斯'
  console.log('obj.name', obj.name) // obj.name 张三
  console.log('obj1.name', obj1.name) // obj1.name 张三
  console.log('obj.friends', obj1.friends) // obj.friends ['里斯', 'wangwu']
  console.log('obj1.friends', obj1.friends) // obj1.friends ['里斯', 'wangwu']

// 对象的浅拷贝
  // ES6 Object.assign
  let obj2 = Object.assign({},obj)
  obj2.name = 'jack'
  console.log('obj1',obj1.name) // 张三
  console.log('obj2',obj2.name) // jack

  // ES6 扩展运算符(...)
  let obj3 = {...obj1}
  obj3.name = 'kobe'
  console.log('obj1',obj1.name) // 张三
  console.log('obj3',obj3.name) // kobe

// 数组的浅拷贝
  // Array.prototype.slice()
  let arr = ['jack',25,{hobby:'tennise'}];
  let arr1 = arr.slice()
  arr1[2].hobby='rose'
  arr1[0]='rose'
  console.log( arr[2].hobby) // rose
  console.log( arr[0]) // jack

  // Array.prototype.concat()
  let arr2 = arr.concat()
  arr2[2].hobby='basketball'
  arr2[0]='rose'
  console.log( arr[2].hobby) // basketball
  console.log( arr[0]) // jack

  // ES6 扩展运算符(...)
  let arr3 = [...arr2]
  arr3[2].hobby='ball'
  arr3[0]='kobe'
  console.log( arr[2].hobby) // ball
  console.log( arr[0]) // jack
```

### 深拷贝
```
深拷贝：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象
```

#### 深拷贝实现方法
```js
// JSON.parse(JSON.stringify())
  // 当对象里面有函数的话，深拷贝后，函数会消失
    var arr = ['jack', 25, { hobby: 'tennise' }];
    let arr1 = JSON.parse(JSON.stringify(arr))
    arr1[2].hobby = 'rose'
    arr1[0] = 'rose'
    console.log(arr[2].hobby) //tennise
    console.log(arr[0]) //jack

// 递归
    function deepClone(obj) {
        let objClone = Array.isArray(obj) ? [] : {};
        if (obj && typeof obj === "object") {
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    //判断obj子元素是否为对象，如果是，递归复制
                    if (obj[key] && typeof obj[key] === "object") {
                        objClone[key] = deepClone(obj[key]);
                    } else {
                        //如果不是，简单复制
                        objClone[key] = obj[key];
                    }
                }
            }
        }
        return objClone;
    }
    
    let a = [1, 2, 3, 4],
        b = deepClone(a)
        a[0] = 2

    console.log(a) // [2, 2, 3, 4]
    console.log(b) // [1, 2, 3, 4]

```

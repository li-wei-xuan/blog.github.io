---
title: vue实例
date: 2022-08-21
tags:
 - vue
# categories:
#  - vue
# keys:
#  - '1a7046021828fad438f8e98b0e8c14d8'
# sticky:
#  - 1
---


## vue文档地址

| 文档 | 地址                                                 |
| ---- | ---------------------------------------------------- |
| Vue2 | [https://v2.cn.vuejs.org/](https://v2.cn.vuejs.org/) |
| Vue3 | [https://cn.vuejs.org/](https://cn.vuejs.org/)       |



## vue实例里的配置项

### el(element(元素))
```js
el用于绑定根元素，一般为CSS选择器字符串

// el的两种写法
// 第一种
new Vue({
  el:'#root'
})

// 第二种
const vm = new Vue({  })
vm.$mount('#root')
```

### data(数据)
```js
data用于定义属性(属性名+属性值)，有两种方法对象式和函数式

// data的两种写法(常用函数方式)
new Vue({
  el:'#root',
  //对象方法,一般用法
  data: {
      name: '张三'
  },
  //函数方法,用于组件,使函数的this指向Vue实例
  data() {
      name: '张三'
  }
})
```

### methods(方法)
```js
methods 方法,主要用于定义绑定事件的方法

<div id="root">
	<button @click="showInfo"></button>
</div>

 <script>
  new Vue({
  	el: '#root',
  	data: {
    	name: '张三',
    	address: '上海'
  	},
  	methods: {  //定义click方法
    	click() {
      	console.log('事件被点击');
    	}
  	}
})
</script>
```

### computed(计算属性)

```js
定义：要用的属性不存在，需要通过已有属性计算得来。  
原理：底层借助了Objcet.defineproperty()方法提供的getter和setter。    
get函数什么时候执行？
    初次读取时会执行一次  
    当依赖的数据发生改变时会被再次调用
优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便  
备注：  
    计算属性最终会出现在vm上，直接读取使用即可  
    如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变  
    如果计算属性确定不考虑修改，可以使用计算属性的简写形式
```
**<font color="red">注意: computed里不能写异步任务</font>**

```html
<div id="root">
    姓：<input type="text" v-model="firstName"><br><br>
    名：<input type="text" v-model="lastName"><br><br>
    姓名：<span>{{fullName}}</span>
</div>

<script>
    new Vue({
        el:'#root',
        data:{
            firstName:'张',
            lastName:'三'
        },
        computed:{
            //完整写法
            /* fullName:{
              get(){
                return this.firstName + '-' + this.lastName
              },
              set(value){
                const arr = value.split('-')
                this.firstName = arr[0]
                this.lastName = arr[1]
              }
            } */
            //简写
            fullName(){
              return this.firstName + '-' + this.lastName
            }
          }
    })
  
  // vue3
  import {computed} from 'vue'

  setup(){
      ...
    //计算属性——简写
      let fullName = computed(()=>{
          return person.firstName + '-' + person.lastName
      })
      //计算属性——完整
      let fullName = computed({
          get(){
              return person.firstName + '-' + person.lastName
          },
          set(value){
              const nameArr = value.split('-')
              person.firstName = nameArr[0]
              person.lastName = nameArr[1]
          }
      })
  }
</script>
```

### watch(监视属性)

```js
1. 当被监视的属性变化时，回调函数自动调用，进行相关操作  
2. 监视的属性必须存在，才能进行监视  
3. 监视有两种写法：  
     创建Vue时传入watch配置  
     通过vm.$watch监视  
4. immediate:true 在初始化时就进行调用  
5. deep:true 开启深度监视,要写成完整形式  
    (1).Vue中的watch默认不监测对象内部值的改变（一层）。
    (2).配置deep:true可以监测对象内部值改变（多层）。  
```
**<font color="red">注意: watch可以写异步任务</font>**

```js
<div id="root">
    姓：<input type="text" v-model="firstName"><br><br>
    名：<input type="text" v-model="lastName"><br><br>
    姓名：<span>{{fullName}}</span>
</div>

<script>
    new Vue({
        el:'#root',
        data:{
            firstName:'张',
            lastName:'三',
            fullName:'张-三'
        },
        watch:{
            firstName(val){
                setTimeout(()=>{
                    this.fullName = val + '-' + this.lastName
                },1000);
            },
            lastName(val){
                this.fullName = this.firstName + '-' + val
            }
        }
    })
</script>

vue3中的两个小“坑”：
  监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。
  监视reactive定义的响应式数据中某个属性时：deep配置有效。
 
//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=>{
	console.log('sum变化了',newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=>{
	console.log('sum或msg变化了',newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=>{
	console.log('person变化了',newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=>person.job,(newValue,oldValue)=>{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=>person.job,()=>person.name],(newValue,oldValue)=>{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=>person.job,(newValue,oldValue)=>{
    console.log('person的job变化了',newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
```

### computed和watch的区别
```
computed和watch之间的区别
  computed能完成的功能，watch都可以完成，能用computed就用computed
  watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作

两个重要的小原则：
  1、所有被 Vue 管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象。
  2、所有不被 Vue 所管理的函数(定时器的回调函数、ajax的回调函数等、Promise的回调函数)，
  最好写成箭头函数，这样this的指向才是vm或组件实例对象。
```

### watchEffect函数

```js
watch的套路是：既要指明监视的属性，也要指明监视的回调。

watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。

watchEffect有点像computed：
	但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。
	而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。

//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=>{
    const x1 = sum.value
    const x2 = person.age
    console.log('watchEffect配置的回调执行了')
})
```


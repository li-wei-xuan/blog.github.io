---
title: vue实例
date: 2022-08-21
tags:
 - vue
# categories:
#  - vue
# keys:
#  - '1a7046021828fad438f8e98b0e8c14d8'
# sticky:
#  - 1
---


## vue文档地址

| 文档 | 地址                                                 |
| ---- | ---------------------------------------------------- |
| Vue2 | [https://v2.cn.vuejs.org/](https://v2.cn.vuejs.org/) |
| Vue3 | [https://cn.vuejs.org/](https://cn.vuejs.org/)       |



## vue实例里的配置项

### el(element(元素))
```js
el用于绑定根元素，一般为CSS选择器字符串

// el的两种写法
// 第一种
new Vue({
  el:'#root'
})

// 第二种
const vm = new Vue({  })
vm.$mount('#root')
```

### data(数据)
```js
data用于定义属性(属性名+属性值)，有两种方法对象式和函数式

// data的两种写法(常用函数方式)
new Vue({
  el:'#root',
  //对象方法,一般用法
  data: {
      name: '张三'
  },
  //函数方法,用于组件,使函数的this指向Vue实例
  data() {
      name: '张三'
  }
})
```

### methods(方法)
```js
methods 方法,主要用于定义绑定事件的方法

<div id="root">
	<button @click="showInfo"></button>
</div>

 <script>
  new Vue({
  	el: '#root',
  	data: {
    	name: '张三',
    	address: '上海'
  	},
  	methods: {  //定义click方法
    	click() {
      	console.log('事件被点击');
    	}
  	}
})
</script>
```

### computed(计算属性)

```js
定义：要用的属性不存在，需要通过已有属性计算得来。  
原理：底层借助了Objcet.defineproperty()方法提供的getter和setter。    
get函数什么时候执行？
    初次读取时会执行一次  
    当依赖的数据发生改变时会被再次调用
优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便  
备注：  
    计算属性最终会出现在vm上，直接读取使用即可  
    如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变  
    如果计算属性确定不考虑修改，可以使用计算属性的简写形式
```
**<font color="red">注意: computed里不能写异步任务</font>**

```html
<div id="root">
    姓：<input type="text" v-model="firstName"><br><br>
    名：<input type="text" v-model="lastName"><br><br>
    姓名：<span>{{fullName}}</span>
</div>

<script>
    new Vue({
        el:'#root',
        data:{
            firstName:'张',
            lastName:'三'
        },
        computed:{
            //完整写法
            /* fullName:{
              get(){
                return this.firstName + '-' + this.lastName
              },
              set(value){
                const arr = value.split('-')
                this.firstName = arr[0]
                this.lastName = arr[1]
              }
            } */
            //简写
            fullName(){
              return this.firstName + '-' + this.lastName
            }
          }
    })
</script>
```

### watch(监视属性)

```js
1. 当被监视的属性变化时，回调函数自动调用，进行相关操作  
2. 监视的属性必须存在，才能进行监视  
3. 监视有两种写法：  
     创建Vue时传入watch配置  
     通过vm.$watch监视  
4. immediate:true 在初始化时就进行调用  
5. deep:true 开启深度监视,要写成完整形式  
    (1).Vue中的watch默认不监测对象内部值的改变（一层）。
    (2).配置deep:true可以监测对象内部值改变（多层）。  
```
**<font color="red">注意: watch可以写异步任务</font>**

```js
<div id="root">
    姓：<input type="text" v-model="firstName"><br><br>
    名：<input type="text" v-model="lastName"><br><br>
    姓名：<span>{{fullName}}</span>
</div>

<script>
    new Vue({
        el:'#root',
        data:{
            firstName:'张',
            lastName:'三',
            fullName:'张-三'
        },
        watch:{
            firstName(val){
                setTimeout(()=>{
                    this.fullName = val + '-' + this.lastName
                },1000);
            },
            lastName(val){
                this.fullName = this.firstName + '-' + val
            }
        }
    })
</script>
```

### computed和watch的区别
```
computed和watch之间的区别
  computed能完成的功能，watch都可以完成，能用computed就用computed
  watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作

两个重要的小原则：
  1、所有被 Vue 管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象。
  2、所有不被 Vue 所管理的函数(定时器的回调函数、ajax的回调函数等、Promise的回调函数)，
  最好写成箭头函数，这样this的指向才是vm或组件实例对象。
```

---
title: JavaScript中的作用域与作用域链
date: 2022-10-10
tags:
 - JavaScript
 - interview
categories:
 - JavaScript
 - interview
---
## JavaScript 中的作用域与[作用域链](#作用域链-scope-chain)
1. [全局作用域](#全局作用域-global-scope)
2. [局部作用域](#局部作用域-local-scope)
3. [块级作用域](#块作用域-block-scope)(ES6+新增的)

### 全局作用域(Global Scope)

:::tip
1. 直接写在script标签的JS代码，都在全局作用域
2. 全局作用域在页面打开的时候创建，在页面关闭时销毁
3. 在全局作用域中有一个对象window,它代表一个浏览器的窗口，它由浏览器创建，我们可以直接使用在全局作用域中：
    1. 创建的变量都会作为window对象的属性保存，全局中的函数都会作为window对象的方法保存
    2. 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问到
:::

```JavaScript
    var globalVariable = "全局作用域变量"
    function func() {    // 在函数内访问全局作用域的变量    
        console.log("函数内访问：", globalVariable)  //函数内访问： 全局作用域变量
    }
    func() //函数外访问： globalVariable
    console.log("外部访问：", globalVariable)  //外部访问： 全局作用域变量

    //使用 var 关键字 在大括号内（包括纯粹的大括号、if、while、for）定义的变量仍然属于全局作用域
    if (true) {
        var globalVariable = "全局作用域变量"
    }
    console.log("外部访问：", globalVariable) //外部访问： 全局作用域变量
```


### 局部作用域(Local Scope)
:::tip
1. 调用函数时创建函数作用域，函数执行完毕以后，作用域销毁
2. 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的
3. 在函数作用域中可以访问全局变量，但在全局作用域中无法访问到局部变量
4. 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一作用域中寻找，直到找到全局作用域，如果全局作用域中仍然没有找到，则会报错ReferenceError
5. 在函数中想要访问全局变量可以使用window对象
:::
```JavaScript
    function func(params) {
        var localVariable = "局部作用域变量"
        console.log("函数内访问：", localVariable) //函数内访问： 局部作用域变量
    }
    func()
    console.log("外部访问：", localVariable) // Uncaught ReferenceError: localVariable is not defined
```
### 块作用域(Block Scope)
:::tip
1. 是一个语句，将多个操作封装在一起，通常是放在一个大括号里，没有返回值。
2. 在ES6之前，函数只能在全局作用域和函数作用域中声明，不能在块级作用域中声明。没有块级作用域导致很多场景不合理
3. 内存变量可能覆盖外层变量
4. 用来计数的循环变量泄露为全局变量
5. ES6中的块级作用域：
    1、允许块级作用域任意嵌套，外层作用域无法读取内层作用域的变量
    2、内层作用域可以定义外层作用域的同名变量
    3、不需要立即执行匿名函数、立即执行函数
:::
```js
    //块作用域内的变量只能在自身作用域内被访问。
    {
        let blockVariable = "块作用域变量"
        console.log("块内访问：", blockVariable) //块内访问： 块作用域变量
    }
    console.log("外部访问：", blockVariable) // Uncaught ReferenceError: blockVariable is not defined
```

### 作用域链(Scope Chain)
:::tip
当一个变量在当前作用域无法找到时，便会尝试寻找其外层的作用域，如果还找不到，再继续往外寻找（只会往外寻找，不会寻找兄弟作用域，更不会往内寻找）。这种如同链条一样的寻找规则便被称为作用域链。
:::
```js
    let variable1 = "我是变量 1，外部的"
    let variable2 = "我是变量 2，外部的"
    function func() {
        let variable1 = "我是变量 1，内部的"
        { let variable3 = "我是变量 3" }
        {
            console.log(variable1) // 往外寻找，在上一层函数内找到了        
            console.log(variable2) // 往外寻找，直到全局作用域     
            console.log(variable3) // 找不到，报错 Uncaught ReferenceError: variable3 is not defined   
        }
    }
    func()

    //函数的作用域是它定义时的作用域，而不是调用时
    function func() {
        let variable = "我是 func 内的变量"
        function func2() {
            console.log(variable)
        }
        return func2
    }
    {
        let variable = "我是大括号内的变量"
        let func2 = func()
        func2()
    }
```

## 作用域的好处
:::tip
1. 防止命名冲突：你写了一万行的代码文件，如果没有作用域，你要给每个变量取独一无二的名字，屁股想想也知道是种折磨。
2. 安全性： 变量不会被外部访问，保证了变量值不会被随意修改。你定义在函数内的变量，如果能在几千行之后不小心被修改，脚趾头想想也知道是种折磨。
3. 更高级的语法：封装、面向对象等的实现离不开对变量的隔离，这是依靠作用域所达到的。
:::

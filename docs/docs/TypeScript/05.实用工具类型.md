---
title: 实用工具类型
date: 2024-07-05
tags:
  - TypeScript
---

### Partial\<Type\>
构造类型Type，并将它所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。

```javascript
interface Todo {
    title: string;
    description: string;
}

let todo: Partial<Todo> = {
    title: 'clean bathroom'
}
console.log(todo); // { title: 'clean bathroom' }
```

### Readonly\<Type\>
构造类型Type，并将它所有的属性设置为readonly，也就是说构造出的类型的属性不能被再次赋值。

```javascript
interface Todo {
    title: string;
    description: string;
}

let todo: Readonly<Todo> = {
    title: 'clean bathroom',
    description: "readonly description"
}
todo.title = 'readonly title' // 无法为“title”赋值，因为它是只读属性。

// 这个工具可用来表示在运行时会失败的赋值表达式（比如，当尝试给冻结对象的属性再次赋值时）。

Object.freeze
    function freeze<T>(obj: T): Readonly<T>;
```

### Record\<Keys, Type\>
构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具可用来将某个类型的属性映射到另一个类型上。

```javascript
interface Todo {
    title: string;
    description: string;
}

type K = 'a' | 'b' 

let todo: Record<K, Todo> = {
    a: {
        title: "",
        description: ""
    },
    b: {
        title: "",
        description: ""
    }
}
```

### Pick\<Type, Keys\>
从类型Type中挑选部分属性Keys来构造类型。

```javascript
interface Todo {
    title: string;
    description: string;
    completed: boolean;
}

type K = Pick<Todo, 'title' | 'completed'>

const list: K = {
    title: 'Learn TypeScript',
    completed: true,
}
```

### Omit\<Type, Keys\>
从类型Type中获取所有属性，然后从中剔除Keys属性后构造一个类型。

```javascript
interface Todo {
    title: string;
    description: string;
    completed: boolean;
}

type ListType = Omit<Todo, 'title' | 'description'>

const list: ListType = {
    completed: false,
}
```

### Exclude\<Type, ExcludedUnion\>
从类型Type中剔除所有可以赋值给ExcludedUnion的属性，然后构造一个类型。

```javascript
type Todo = 'title' | 'description' | 'completed'

type ListType = Exclude<Todo, 'title' | 'description'>

const list: ListType = 'completed'
```

### Extract\<Type, Union\>
从类型Type中提取所有可以赋值给Union的类型，然后构造一个类型

```javascript
type T = Extract<'a' | 'b' | 'c', 'c' | 'f'>; // "c"
type T1 = Extract<string | number | (() => void), Function>;
```

### NonNullable\<Type\>
从类型Type中剔除null和undefined，然后构造一个类型。

```javascript
type T =  NonNullable<null | undefined | string | number> // 'string' | 'number'
type T1 =  NonNullable<null | string | number | boolean> // 'string' | 'number' | 'boolean'
```

### Parameters\<Type\>
由函数类型Type的参数类型来构建出一个元组类型。

```javascript
declare function f1(arg: { a: number; b: string }): void;

type T0 = Parameters<() => string>;
//    []
type T1 = Parameters<(s: string) => void>;
//    [s: string]
type T2 = Parameters<<T>(arg: T) => T>;
//    [arg: unknown]
type T3 = Parameters<typeof f1>;
//    [arg: { a: number; b: string; }]
type T4 = Parameters<any>;
//    unknown[]
type T5 = Parameters<never>;
//    never
type T6 = Parameters<string>;
//   never
//   Type 'string' does not satisfy the constraint '(...args: any) => any'.
type T7 = Parameters<Function>;
//   never
//   Type 'Function' does not satisfy the constraint '(...args: any) => any'.
```

### ConstructorParameters\<Type\>
由构造函数类型来构建出一个元组类型或数组类型。  
由构造函数类型Type的参数类型来构建出一个元组类型。（若Type不是构造函数类型，则返回never）。

```javascript
type T0 = ConstructorParameters<ErrorConstructor>;
//    [message?: string | undefined]
type T1 = ConstructorParameters<FunctionConstructor>;
//    string[]
type T2 = ConstructorParameters<RegExpConstructor>;
//    [pattern: string | RegExp, flags?: string | undefined]
type T3 = ConstructorParameters<any>;
//   unknown[]

type T4 = ConstructorParameters<Function>;
//    never
// Type 'Function' does not satisfy the constraint 'new (...args: any) => any'.

```

### ReturnType\<Type\>
由函数类型Type的返回值类型构建一个新类型。

```javascript
type T0 = ReturnType<() => string>;  // string
type T1 = ReturnType<(s: string) => void>;  // void
type T2 = ReturnType<(<T>() => T)>;  // {}
type T3 = ReturnType<(<T extends U, U extends number[]>() => T)>;  // number[]
```

### InstanceType\<Type\>
由构造函数类型Type的实例类型来构建一个新类型。

```javascript
class C {
    x = 0;
    y = 0;
}

type T0 = InstanceType<typeof C>; // C
type T1 = InstanceType<any>; // any
type T2 = InstanceType<never>; // any
type T3 = InstanceType<string>; // Error
type T4 = InstanceType<Function>; // Error

```

### Required\<Type\>
构建一个类型，使类型Type的所有属性为required。 与此相反的是Partial。

```javascript
interface Props {
    a?: number;
    b?: string;
}

const obj: Props = { a: 5 }; // OK

const obj2: Required<Props> = { a: 5 }; // Error: property 'b' missing

```

### ThisParameterType\<Type\>
从函数类型中提取 this 参数的类型。 若函数类型不包含 this 参数，则返回 unknown 类型。

```javascript
function toHex(this: Number) {
    return this.toString(16);
}

function numberToString(n: ThisParameterType<typeof toHex>) {
    return toHex.apply(n);
}

```

### OmitThisParameter\<Type\>
从Type类型中剔除 this 参数。 若未声明 this 参数，则结果类型为 Type 。  
否则，由Type类型来构建一个不带this参数的类型。 泛型会被忽略，并且只有最后的重载签名会被采用。

```javascript
function toHex(this: Number) {
    return this.toString(16);
}

const fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);

console.log(fiveToHex());

```

### ThisType\<Type\>
这个工具不会返回一个转换后的类型。 它做为上下文的this类型的一个标记。  
注意，若想使用此类型，必须启用--noImplicitThis。

```javascript
// Compile with --noImplicitThis
type ObjectDescriptor<D, M> = {
    data?: D;
    methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M
};

function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {
    let data: object = desc.data || {};
    let methods: object = desc.methods || {};
    return { ...data, ...methods } as D & M;
}

let obj = makeObject({
    data: { x: 0, y: 0 },
    methods: {
        moveBy(dx: number, dy: number) {
            this.x += dx; // Strongly typed this
            this.y += dy; // Strongly typed this
        },
    },
});

obj.x = 10;
obj.y = 20;
obj.moveBy(5, 5);

```